using System;
using AOT;
using Unity.Burst;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Mathematics;
using UnityEngine;
using UnityEngine.Tilemaps;

using Random = Unity.Mathematics.Random;

namespace Unity.Tilemaps.Experimental
{
    /// <summary>
    ///     Animated Tiles are tiles which run through and display a list of sprites in sequence.
    /// </summary>
    [BurstCompile]
    [Serializable]
    [HelpURL(
        "https://docs.unity3d.com/Packages/com.unity.2d.tilemap.extras@latest/index.html?subfolder=/manual/AnimatedEntityIdTile.html")]
    public class AnimatedEntityIdTile : EntityIdTileBase
    {
        [SerializeField]
        private Sprite[] m_AnimatedSprites;

        [SerializeField]
        private float m_MinSpeed = 1f;

        [SerializeField]
        private float m_MaxSpeed = 1f;

        [SerializeField]
        private float m_AnimationStartTime;

        [SerializeField]
        private int m_AnimationStartFrame;

        [SerializeField]
        private Tile.ColliderType m_TileColliderType;

        [SerializeField]
        private TileAnimationFlags m_TileAnimationFlags;

        /// <summary>
        ///     The List of Sprites set for the Animated Tile.
        ///     This will be played in sequence.
        /// </summary>
        public Sprite[] animatedSprites
        {
            get { return m_AnimatedSprites; }
            set
            {
                m_AnimatedSprites = value;
                if (m_Data.m_AnimatedSpriteEntityIds.IsCreated)
                    m_Data.m_AnimatedSpriteEntityIds.Dispose();
                var hasAnimatedSprites = m_AnimatedSprites != null && m_AnimatedSprites.Length > 0;
                var spriteEntityId = hasAnimatedSprites
                    ? m_AnimatedSprites[^1] != null ? m_AnimatedSprites[^1].GetEntityId() : EntityId.None
                    : EntityId.None;
                m_Data.m_TileData.spriteEntityId = spriteEntityId;
                if (hasAnimatedSprites)
                {
                    m_Data.m_AnimatedSpriteEntityIds =
                        new NativeArray<EntityId>(m_AnimatedSprites?.Length ?? 0, Allocator.Persistent);
                    for (var i = 0; i < m_AnimatedSprites.Length; i++)
                    {
                        var sprite = m_AnimatedSprites[i];
                        m_Data.m_AnimatedSpriteEntityIds[i] = sprite != null ? sprite.GetEntityId() : default;
                    }
                }
            }
        }

        /// <summary>
        ///     The minimum possible speed at which the Animation of the Tile will be played.
        ///     A speed value will be randomly chosen between the minimum and maximum speed.
        /// </summary>
        public float minSpeed
        {
            get { return m_MinSpeed; }
            set
            {
                m_MinSpeed = value;
                m_Data.m_MinSpeed = value;
            }
        }

        /// <summary>
        ///     The maximum possible speed at which the Animation of the Tile will be played.
        ///     A speed value will be randomly chosen between the minimum and maximum speed.
        /// </summary>
        public float maxSpeed
        {
            get { return m_MaxSpeed; }
            set
            {
                m_MaxSpeed = value;
                m_Data.m_MaxSpeed = value;
            }
        }

        /// <summary>
        ///     The starting time of this Animated Tile.
        ///     This allows you to start the Animation from time in the list of Animated Sprites depending on the
        ///     Tilemap's Animation Frame Rate.
        /// </summary>
        public float animationStartTime
        {
            get { return m_AnimationStartTime; }
            set
            {
                m_AnimationStartTime = value;
                m_Data.m_AnimationStartTime = value;
            }
        }

        /// <summary>
        ///     The starting frame of this Animated Tile.
        ///     This allows you to start the Animation from a particular Sprite in the list of Animated Sprites.
        ///     If this is set, this overrides m_AnimationStartTime.
        /// </summary>
        public int animationStartFrame
        {
            get { return m_AnimationStartFrame; }
            set
            {
                m_AnimationStartFrame = value;
                m_Data.m_AnimationStartFrame = value;
            }
        }

        /// <summary>
        ///     The Collider Shape generated by the Tile.
        /// </summary>
        public Tile.ColliderType tileColliderType
        {
            get { return m_TileColliderType; }
            set
            {
                m_TileColliderType = value;
                m_Data.m_TileData.colliderType = value;
            }
        }

        /// <summary>
        ///     Flags for controlling the Tile Animation.
        /// </summary>
        public TileAnimationFlags tileAnimationFlags
        {
            get { return m_TileAnimationFlags; }
            set
            {
                m_TileAnimationFlags = value;
                m_Data.m_TileAnimationFlags = value;
            }
        }

        private struct AnimatedEntityIdData : IDisposable
        {
            public TileData m_TileData;

            public NativeArray<EntityId> m_AnimatedSpriteEntityIds;
            public float m_MinSpeed;
            public float m_MaxSpeed;
            public float m_AnimationStartTime;
            public int m_AnimationStartFrame;
            public TileAnimationFlags m_TileAnimationFlags;
            public Unity.Mathematics.Random m_Random;

            public void Dispose()
            {
                if (m_AnimatedSpriteEntityIds.IsCreated)
                    m_AnimatedSpriteEntityIds.Dispose();
            }
        }

        private AnimatedEntityIdData m_Data;

        /// <summary>
        /// Initialises the AnimatedEntityIdTile
        /// </summary>
        public override void OnEnable()
        {
            base.OnEnable();
            OnValidate();
        }

        /// <summary>
        /// Does clean up for the AnimatedEntityIdTile
        /// </summary>
        public override void OnDisable()
        {
            m_Data.Dispose();
            base.OnDisable();
        }

        /// <summary>
        /// Copies the Data struct used for this AnimatedEntityIdTile to the outPtr buffer
        /// for use in Unity Jobs.
        /// </summary>
        /// <param name="outPtr">Data buffer to copy data struct from AnimatedEntityIdTile to.</param>
        public override unsafe void CopyDataStruct(void* outPtr)
        {
            UnsafeUtility.CopyStructureToPtr(ref m_Data, outPtr);
        }

        /// <summary>
        /// Returns the delegate function called by Tilemap using Unity Jobs to refresh AnimatedEntityIdTiles
        /// </summary>
        protected override unsafe RefreshTileJobDelegate refreshTileJobDelegate => RefreshTileJob;

        /// <summary>
        /// Returns the delegate function called by Tilemap using Unity Jobs to get Tile Data from AnimatedEntityIdTiles
        /// </summary>
        protected override unsafe GetTileDataJobDelegate getTileDataJobDelegate => GetTileDataJob;

        /// <summary>
        /// Returns the delegate function called by Tilemap using Unity Jobs to get Tile Animation Data from AnimatedEntityIdTiles
        /// </summary>
        protected override unsafe GetTileAnimationDataJobDelegate getTileAnimationDataJobDelegate => GetTileAnimationDataJob;

        /// <summary>
        /// Returns the type of data struct used for the AnimatedEntityIdTile,
        /// which is the type of AnimatedEntityIdData.
        /// </summary>
        public override Type structType => typeof(AnimatedEntityIdData);

        private void OnValidate()
        {
            m_Data.Dispose();
            var hasAnimatedSprites = m_AnimatedSprites != null && m_AnimatedSprites.Length > 0;
            var spriteEntityId = hasAnimatedSprites
                ? m_AnimatedSprites[^1] != null ? m_AnimatedSprites[^1].GetEntityId() : EntityId.None
                : EntityId.None;

            m_Data = new AnimatedEntityIdData()
            {
                m_TileData = new TileData()
                {
                    spriteEntityId = spriteEntityId,
                    color = Color.white,
                    colliderType = m_TileColliderType,
                    gameObjectEntityId = EntityId.None,
                    transform = Matrix4x4.identity,
                    flags = TileFlags.LockColor,
                },
                m_AnimatedSpriteEntityIds = new NativeArray<EntityId>(m_AnimatedSprites?.Length ?? 0, Allocator.Persistent),
                m_MinSpeed = m_MinSpeed,
                m_MaxSpeed = m_MaxSpeed,
                m_AnimationStartTime = m_AnimationStartTime,
                m_AnimationStartFrame = m_AnimationStartFrame,
                m_TileAnimationFlags = m_TileAnimationFlags,
                m_Random = new Unity.Mathematics.Random(Convert.ToUInt32(Math.Abs(cachedEntityId.GetHashCode())))
            };
            if (hasAnimatedSprites)
            {
                for (var i = 0; i < m_AnimatedSprites.Length; i++)
                {
                    var sprite = m_AnimatedSprites[i];
                    m_Data.m_AnimatedSpriteEntityIds[i] = sprite != null ? sprite.GetEntityId() : default;
                }
            }
        }

        [BurstCompile]
        [MonoPInvokeCallback(typeof(RefreshTileJobDelegate))]
        static unsafe void RefreshTileJob(int count, int3* position, void* data, ref TilemapRefreshStruct tilemapRefreshStruct)
        {
            for (var i = 0; i < count; ++i)
            {
                var pos = position + i;
                tilemapRefreshStruct.RefreshTile(*pos);
            }
        }

        [BurstCompile]
        [MonoPInvokeCallback(typeof(GetTileDataJobDelegate))]
        static unsafe void GetTileDataJob(int count, int3* position, void* data, ref TilemapDataStruct tilemapDataStruct, TileData* outTileData)
        {
            AnimatedEntityIdData tileData = UnsafeUtility.AsRef<AnimatedEntityIdData>(data);
            for (var i = 0; i < count; ++i)
            {
                UnsafeUtility.CopyPtrToStructure(UnsafeUtility.AddressOf(ref tileData.m_TileData), out *(outTileData + i));
            }
        }

        [BurstCompile]
        [MonoPInvokeCallback(typeof(GetTileAnimationDataJobDelegate))]
        static unsafe void GetTileAnimationDataJob(int count, int3* position, void* data, ref TilemapDataStruct tilemapDataStruct, TileAnimationEntityIdData* outTileAnimationEntityIdData)
        {
            AnimatedEntityIdData tileData = UnsafeUtility.AsRef<AnimatedEntityIdData>(data);
            float animationStartTime = tileData.m_AnimationStartTime;
            float animationFrameRate = tilemapDataStruct.GetTileAnimationFrameRate();
            if (0 < tileData.m_AnimationStartFrame
                && tileData.m_AnimationStartFrame <= tileData.m_AnimatedSpriteEntityIds.Length
                && tilemapDataStruct.GetTileAnimationFrameRate() > 0)
            {
                animationStartTime = (tileData.m_AnimationStartFrame - 1) / animationFrameRate;
            }

            for (var i = 0; i < count; ++i)
            {
                ref TileAnimationEntityIdData outTileAnimationData = ref *(outTileAnimationEntityIdData + i);
                if (tileData.m_AnimatedSpriteEntityIds.IsCreated)
                    outTileAnimationData.animatedSpritesEntityIds = tileData.m_AnimatedSpriteEntityIds;
                outTileAnimationData.animationSpeed =
                    tileData.m_Random.NextFloat(tileData.m_MinSpeed, tileData.m_MaxSpeed);
                outTileAnimationData.animationStartTime = animationStartTime;
                outTileAnimationData.flags = tileData.m_TileAnimationFlags;
            }
        }

        /// <summary>
        ///     Retrieves any tile rendering data from the scripted tile.
        /// </summary>
        /// <param name="position">Position of the Tile on the Tilemap.</param>
        /// <param name="tilemap">The Tilemap the tile is present on.</param>
        /// <param name="tileData">Data to render the tile.</param>
        public override void GetTileData(Vector3Int position, ITilemap tilemap, ref TileData tileData)
        {
            unsafe
            {
                UnsafeUtility.CopyPtrToStructure(UnsafeUtility.AddressOf(ref m_Data.m_TileData), out tileData);
            }
        }

        /// <summary>
        ///     Retrieves any tile animation data from the scripted tile.
        /// </summary>
        /// <param name="position">Position of the Tile on the Tilemap.</param>
        /// <param name="tilemap">The Tilemap the tile is present on.</param>
        /// <param name="tileAnimationData">Data to run an animation on the tile.</param>
        /// <returns>Whether the call was successful.</returns>
        public override bool GetTileAnimationData(Vector3Int position, ITilemap tilemap,
            ref TileAnimationData tileAnimationData)
        {
            if (m_AnimatedSprites.Length > 0)
            {
                tileAnimationData.animatedSprites = m_AnimatedSprites;
                tileAnimationData.animationSpeed = m_Data.m_Random.NextFloat(m_MinSpeed, m_MaxSpeed);
                tileAnimationData.animationStartTime = m_AnimationStartTime;
                tileAnimationData.flags = m_TileAnimationFlags;
                if (0 < m_AnimationStartFrame && m_AnimationStartFrame <= m_AnimatedSprites.Length)
                {
                    var tilemapComponent = tilemap.GetComponent<Tilemap>();
                    if (tilemapComponent != null && tilemapComponent.animationFrameRate > 0)
                        tileAnimationData.animationStartTime =
                            (m_AnimationStartFrame - 1) / tilemapComponent.animationFrameRate;
                }
                return true;
            }
            return false;
        }
    }
}
